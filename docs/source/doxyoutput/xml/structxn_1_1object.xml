<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="structxn_1_1object" kind="struct" language="C++" prot="public">
    <compoundname>xn::object</compoundname>
    <basecompoundref refid="classpy_1_1dict" prot="public" virt="non-virtual">py::dict&lt; const char *, std::any &gt;</basecompoundref>
    <derivedcompoundref refid="classxn_1_1Graph" prot="public" virt="non-virtual">xn::Graph&lt; nodeview_t, nodemap_t &gt;</derivedcompoundref>
    <derivedcompoundref refid="classxn_1_1Graph" prot="public" virt="non-virtual">xn::Graph&lt; nodeview_t, nodemap_t, adjlist_inner_dict_factory &gt;</derivedcompoundref>
    <includes refid="graph_8hpp" local="no">graph.hpp</includes>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Base class for undirected graphs.</para><para>A <ref refid="classxn_1_1Graph" kindref="compound">Graph</ref> stores nodes and edges with optional data, or attributes.</para><para>Graphs hold undirected edges. Self loops are allowed but multiple (parallel) edges are not.</para><para>Nodes can be arbitrary (hashable) C++ objects with optional key/value attributes. By convention <computeroutput>None</computeroutput> is not used as a node.</para><para>Edges are represented as links between nodes with optional key/value attributes.</para><para><heading level="2">Parameters </heading>
</para><para>node_container : input graph (optional, default: None) Data to initialize graph. If None (default) an empty graph is created. The data can be any format that is supported by the to_networkx_graph() function, currently including edge list, dict of dicts, dict of lists, NetworkX graph, NumPy matrix or 2d ndarray, SciPy sparse matrix, or PyGraphviz graph.</para><para><heading level="2">See Also </heading>
</para><para>DiGraph MultiGraph MultiDiGraph OrderedGraph</para><para><heading level="2">Examples </heading>
</para><para>Create an empty graph structure (a &quot;null graph&quot;) with 5 nodes and no edges.</para><para><blockquote><para><blockquote><para><blockquote><para>auto v = std::vector{3, 4, 2, 8}; auto G = <ref refid="classxn_1_1Graph" kindref="compound">xn::Graph(v)</ref>; </para></blockquote></para></blockquote></para></blockquote></para><para><blockquote><para><blockquote><para><blockquote><para>auto va = <ref refid="classpy_1_1dict" kindref="compound">py::dict</ref>{{3, 0.1}, {4, 0.5}, {2, 0.2}}; auto G = <ref refid="classxn_1_1Graph" kindref="compound">xn::Graph(va)</ref>; </para></blockquote></para></blockquote></para></blockquote></para><para><blockquote><para><blockquote><para><blockquote><para>auto r = py::range(100); auto G = <ref refid="classxn_1_1Graph" kindref="compound">xn::Graph(r)</ref>; </para></blockquote></para></blockquote></para></blockquote></para><para>G can be grown in several ways.</para><para>Nodes:**</para><para>Add one node at a time:</para><para><blockquote><para><blockquote><para><blockquote><para>G.add_node(1) </para></blockquote></para></blockquote></para></blockquote></para><para>Add the nodes from any container (a list, dict, set or even the lines from a file or the nodes from another graph).</para><para><blockquote><para><blockquote><para><blockquote><para>G.add_nodes_from([2, 3]) G.add_nodes_from(range(100, 110)) H = xn::path_graph(10) G.add_nodes_from(H) </para></blockquote></para></blockquote></para></blockquote></para><para>In addition to strings and integers any hashable C++ object (except None) can represent a node, e.g. a customized node object, or even another <ref refid="classxn_1_1Graph" kindref="compound">Graph</ref>.</para><para><blockquote><para><blockquote><para><blockquote><para>G.add_node(H) </para></blockquote></para></blockquote></para></blockquote></para><para>Edges:**</para><para>G can also be grown by adding edges.</para><para>Add one edge,</para><para><blockquote><para><blockquote><para><blockquote><para>G.add_edge(1, 2); </para></blockquote></para></blockquote></para></blockquote></para><para>a list of edges,</para><para><blockquote><para><blockquote><para><blockquote><para>G.add_edges_from([(1, 2), (1, 3)]); </para></blockquote></para></blockquote></para></blockquote></para><para>or a collection of edges,</para><para><blockquote><para><blockquote><para><blockquote><para>G.add_edges_from(H.edges); </para></blockquote></para></blockquote></para></blockquote></para><para>If some edges connect nodes not yet in the graph, the nodes are added automatically. There are no errors when adding nodes or edges that already exist.</para><para>Attributes:**</para><para>Each graph can hold key/value attribute pairs in an associated attribute dictionary (the keys must be hashable). By default these are empty, but can be added or changed using direct manipulation of the attribute dictionaries named graph, node and edge respectively.</para><para><blockquote><para><blockquote><para><blockquote><para>G.graph[&quot;day&quot;] = std::any(&quot;Friday&quot;); </para></blockquote></para></blockquote></para></blockquote>{&apos;day&apos;: &apos;Friday&apos;}</para><para>Subclasses (Advanced):**</para><para>The <ref refid="classxn_1_1Graph" kindref="compound">Graph</ref> class uses a container-of-container-of-container data structure. The outer dict (node_dict) holds adjacency information keyed by node. The next dict (adjlist_dict) represents the adjacency information and holds edge data keyed by neighbor. The inner dict (edge_attr_dict) represents the edge data and holds edge attribute values keyed by attribute names.</para><para>Each of these three dicts can be replaced in a subclass by a user defined dict-like object. In general, the dict-like features should be maintained but extra features can be added. To replace one of the dicts create a new graph class by changing the class(!) variable holding the factory for that dict-like structure. The variable names are node_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory, adjlist_outer_dict_factory, edge_attr_dict_factory and graph_attr_dict_factory.</para><para>node_dict_factory : function, (default: dict) Factory function to be used to create the dict containing node attributes, keyed by node id. It should require no arguments and return a dict-like object</para><para>node_attr_dict_factory: function, (default: dict) Factory function to be used to create the node attribute dict which holds attribute values keyed by attribute name. It should require no arguments and return a dict-like object</para><para>adjlist_outer_dict_factory : function, (default: dict) Factory function to be used to create the outer-most dict in the data structure that holds adjacency info keyed by node. It should require no arguments and return a dict-like object.</para><para>adjlist_inner_dict_factory : function, (default: dict) Factory function to be used to create the adjacency list dict which holds edge data keyed by neighbor. It should require no arguments and return a dict-like object</para><para>edge_attr_dict_factory : function, (default: dict) Factory function to be used to create the edge attribute dict which holds attribute values keyed by attribute name. It should require no arguments and return a dict-like object.</para><para>graph_attr_dict_factory : function, (default: dict) Factory function to be used to create the graph attribute dict which holds attribute values keyed by attribute name. It should require no arguments and return a dict-like object.</para><para>Typically, if your extension doesn&apos;t impact the data structure all methods will inherit without issue except: <computeroutput>to_directed/to_undirected</computeroutput>. By default these methods create a DiGraph/Graph class and you probably want them to create your extension of a DiGraph/Graph. To facilitate this we define two class variables that you can set in your subclass.</para><para>to_directed_class : callable, (default: DiGraph or MultiDiGraph) Class to create a new graph structure in the <computeroutput>to_directed</computeroutput> method. If <computeroutput>None</computeroutput>, a NetworkX class (DiGraph or MultiDiGraph) is used.</para><para>to_undirected_class : callable, (default: <ref refid="classxn_1_1Graph" kindref="compound">Graph</ref> or MultiGraph) Class to create a new graph structure in the <computeroutput>to_undirected</computeroutput> method. If <computeroutput>None</computeroutput>, a NetworkX class (<ref refid="classxn_1_1Graph" kindref="compound">Graph</ref> or MultiGraph) is used.</para><para><heading level="2">Examples </heading>
</para><para>Create a low memory graph class that effectively disallows edge attributes by using a single attribute dict for all edges. This reduces the memory used, but you lose edge attributes.</para><para><blockquote><para><blockquote><para><blockquote><para>class ThinGraph(xn::Graph): </para></blockquote></para></blockquote></para></blockquote>... all_edge_dict = {&apos;weight&apos;: 1} ... def single_edge_dict(self): ... return self.all_edge_dict ... edge_attr_dict_factory = single_edge_dict <blockquote><para><blockquote><para><blockquote><para>G = ThinGraph() G.add_edge(2, 1) G[2][1] </para></blockquote></para></blockquote></para></blockquote>{&apos;weight&apos;: 1} <blockquote><para><blockquote><para><blockquote><para>G.add_edge(2, 2) G[2][1] is G[2][2] </para></blockquote></para></blockquote></para></blockquote>True</para><para>Please see :mod:<computeroutput>~networkx.classes.ordered</computeroutput> for more examples of creating graph subclasses by overwriting the base class <computeroutput>dict</computeroutput> with a dictionary-like object. </para>    </detaileddescription>
    <inheritancegraph>
      <node id="230">
        <label>xn::Graph&lt; nodeview_t, nodemap_t &gt;</label>
        <link refid="classxn_1_1Graph"/>
        <childnode refid="227" relation="public-inheritance">
        </childnode>
      </node>
      <node id="232">
        <label>xn::VertexView&lt; Graph &gt;</label>
        <link refid="classxn_1_1VertexView"/>
        <childnode refid="231" relation="public-inheritance">
        </childnode>
      </node>
      <node id="231">
        <label>xn::Graph&lt; nodeview_t, nodemap_t, adjlist_inner_dict_factory &gt;</label>
        <link refid="classxn_1_1Graph"/>
        <childnode refid="227" relation="public-inheritance">
        </childnode>
      </node>
      <node id="227">
        <label>xn::object</label>
        <link refid="structxn_1_1object"/>
        <childnode refid="228" relation="public-inheritance">
        </childnode>
      </node>
      <node id="229">
        <label>std::unordered_map&lt; const char *, std::any &gt;</label>
      </node>
      <node id="228">
        <label>py::dict&lt; const char *, std::any &gt;</label>
        <link refid="classpy_1_1dict"/>
        <childnode refid="229" relation="public-inheritance">
        </childnode>
      </node>
      <node id="233">
        <label>xn::grAdaptor&lt; Graph &gt;</label>
        <link refid="classxn_1_1grAdaptor"/>
        <childnode refid="232" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="234">
        <label>xn::object</label>
        <link refid="structxn_1_1object"/>
        <childnode refid="235" relation="public-inheritance">
        </childnode>
      </node>
      <node id="236">
        <label>std::unordered_map&lt; const char *, std::any &gt;</label>
      </node>
      <node id="235">
        <label>py::dict&lt; const char *, std::any &gt;</label>
        <link refid="classpy_1_1dict"/>
        <childnode refid="236" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/media/lubuntu/USBDISK/github/ckpttncpp/lib/include/xnetwork/classes/graph.hpp" line="199" column="1" bodyfile="/media/lubuntu/USBDISK/github/ckpttncpp/lib/include/xnetwork/classes/graph.hpp" bodystart="198" bodyend="200"/>
    <listofallmembers>
      <member refid="classpy_1_1dict_1aa7fa8bf2e9f18a3f16642566c4c595f2" prot="public" virt="non-virtual"><scope>xn::object</scope><name>dict</name></member>
      <member refid="classpy_1_1dict_1a1cea0f6dc3fd12ba2ed5c9d217141b4b" prot="public" virt="non-virtual"><scope>xn::object</scope><name>dict</name></member>
      <member refid="classpy_1_1dict_1a8fd455a25ca9e64e8d0565c3a39b6b94" prot="public" virt="non-virtual"><scope>xn::object</scope><name>operator=</name></member>
      <member refid="classpy_1_1dict_1a688c7f90e289301289804ade491808fa" prot="public" virt="non-virtual"><scope>xn::object</scope><name>value_type</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
